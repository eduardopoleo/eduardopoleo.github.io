---
layout: post
title: "Unix. A History and a Memoir"
date: 2020-01-11
published: true
---

I had some free time over the holidays and ended up reading [A History and a Memoir](https://www.amazon.com/dp/1695978552). As the name suggests the book tells the history of the [Unix](https://en.wikipedia.org/wiki/Unix) operating system and also talks about [Brian Kernighan](https://en.wikipedia.org/wiki/Brian_Kernighan)'s experience at [Bell Labs](https://en.wikipedia.org/wiki/Bell_Labs) from the time he started as an intern in 1967 all the way to his retirement in 2000. This post summarizes some my take aways from the book.

## Everlasting contributions
Although I had heard mentions of Unix and "the" Bell Labs before I had no idea of the magnitude of their contributions. According to Kernighan to this day nine [Nobel Prices](https://en.wikipedia.org/wiki/Nobel_Prize) and a good number of [Turing awards](https://en.wikipedia.org/wiki/Turing_Award) have been awarded to research done at least partially at Bell Labs. Some of the well know achievements to have come out the the labs include transistors, solar panels, cellular phones, lasers among many others!

## Long term projects = big payoffs
At the time the Labs was created [AT&T](https://en.wikipedia.org/wiki/AT%26T) had a regulated, and for the most part uncontested, monopoly on the US communication infrastructure. Such monopoly ensured a steady income for the company and most its ventures, which of course included Bell Labs. This allowed the company to take a long term view to research and project development, thus researches were allowed, and perhaps encouraged, to choose projects that satisfied their intellectual curiosity without ever worrying about their near term payoff.

## Extreme Collaboration
Money alone was not the only key ingredient for Bell Labs success, right from the very first day all researches and technologist were encouraged to collaborate with each other. So much so that it was a standard practice for new members of the team to join without any project assignment, instead they were expected to interact with their peers and organically gravitate to the areas that better fit their interests. Also while team members were provided with their own offices their doors were expected to remain open most of time to encourage people popping in if they had any questions or just something interesting to discuss. There were also shared spaces, for which the most iconic one was the "UNIX room" where people could just work, hang out and get a sense of what everybody else was up to. 

Collaboration was even encouraged at a policy/institutional level through the review process. Promotions and pay raises were significantly influenced by peers and managers recommendations so the more people you had vouching for you the more chances you had to do great. It was then to the best of interest of researches to collaborate on a wide variety of projects and teams as opposed to focus deeply on only one thing.

## C 
By the time UNIX was still brewing most operating system were written on proprietary machine (assembly) languages made specifically for the computer architecture they ran on, this made OSes practically impossible to port. [C](https://en.wikipedia.org/wiki/C_programming_language) was created along side UNIX as a succinct and higher level language good for system programming. The fact that UNIX was written in C meant that it could potentially be ported to any computer provided that you had a working C compiler on that machine. While writing a compiler was not a trivial task it was more straight forward than writing a full production ready OS on assembly and as C became more ubiquitous the cost of porting UNIX decreased substantially.  

## Language Technology
One key idea that sprang up in the efforts to make programs portable was to split the compilation process into 2 pieces or steps: frontend (FE) and backend (BE). The insight here was that while every computer architecture was different the syntax and semantics of a language was always going to be the same so it made sense to have a common FE to do the lexical and grammar analysis of the program. This reduced the work of creating a compiler to write a BE that translated the FE output to the specific machine language you need to compile to. 

Consequently, two tools were developed, [LEX](https://en.wikipedia.org/wiki/Lex_(software)) which would perform lexical analysis over the code and split it into tokens, and [YACC](https://en.wikipedia.org/wiki/Yacc) which will receive such tokens and perform semantic analysis on them. Both of these would work in tandem to provide a common compiler FE that could be coupled with different BEs for each target architecture. YACC and LEX made it easier to non experts to create their own domain specific languages some of the most notables being, [bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) and [awk](https://en.wikipedia.org/wiki/AWK).

## Unix
The origins of Unix were somewhat curious and fortuitous. At some point the MIT wanted to improve over its success with the [CTSS](https://en.wikipedia.org/wiki/Compatible_Time-Sharing_System) and started a grandiose design for [Multics](https://en.wikipedia.org/wiki/Multics) which was supposed to be superior on all accounts to its predecessor. They enlisted two big organizations to help out with project: General Electrics, which at the time was major computer hardware player, was going to build the computer, while Bell Labs was tasked with developing the OS. Let just say that Multics turned out not be a great hit. The project ended up suffering from the [second system effect](https://en.wikipedia.org/wiki/Second-system_effect) and the nightmarish logistics of coordinating work among three disjointed institutions did not help either. After a couple of years Bell Labs split but the whole episode marked the team in different ways.

On one hand you had management who wanted to bury the experience altogether stirring away from any subsequent OS related projects, but on the other you had technologist such [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson) and [Dennis Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie), who were left wanting more. At some point not long after the split Ken found himself playing around with a small computer that had a peculiar feature, its disk unit was more powerful than the cpu could handle. Thus, in good geek style he proceeded to write a disk scheduling algorithm that could be used to safely maximize disk usage. After a little while he realized that he needed a way to test his code and according to the book he came to the conclusion that he *"was just 3 weeks away an operating system"*, he then went onto building an editor, an assembly and a kernel layer during those 3 weeks making Unix pop into existence.

The rest is quite literally history. Unix along with C started spreading first within different departments and later on to universities and finally industry becoming runaway successes. A&T wanting to capitalize on this implemented some strict licensing rules which very quickly incentivized the creation of clones OSes that while sharing in the Unix philosophy were completely written from scratch and open source, the most relevant of these of course being [Linux](https://en.wikipedia.org/wiki/Linux).